
    <html>
      <head>
        <link href='http://fonts.googleapis.com/css?family=Titillium+Web' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>

        <meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <style>
          html {
  font-family: 'Roboto';
  font-size: 18pt;
  margin: 0px;
}

a {
  text-decoration: none;
  color: #6699cc;
}

h1 {
  padding-top: 0px;
  margin-top: 0px;
  font-size: 2em;
}

h2 {
  font-size: 1.5em;
}

.chapter {
  margin-top: 1px;
  page-break-before: always;
  line-height: 1.5em;
  width: 1042px;
}

.chapter img {
  width: 1042px;
}

.page-break {
  page-break-before: always;
}

pre {
  border: 1px solid #dfdfdf;
  padding: 15px;
}

code {
  font-family: 'Droid Sans Mono';
}

p code {
  color: #232323;
  font-size: 0.9em;
  padding: 1px 2px 2px 2px;
  color: #c7254e;
  background-color: #f6f6f6;
}

.example-header-wrap {
  position: relative;
  height: 0px;
}

.example-header {
  border: 1px solid #dfdfdf;
  top: -15px;
  padding-top: 0px;
  height: 1em;
  padding: 1px;
  position: absolute;
  width: 7em;
  text-align: center;
  color: #666;
  font-size: 0.5em;
  line-height: 1em;
}

.toc a {
  font-size: 18pt;
  color: #232323;
  float: right;
  font-weight: bold;
}

.toc ol {
  padding-left: 2.5em;
}

.toc li {
  margin-left: 0px;
  line-height: 1.5em;
}

.toc a::after {
  content: '';
  clear: both;
  display: table;
}

svg {
  width: 800px;
  margin-left: 100px;
  margin-bottom: 15px;
}

/*
github.com style (c) Vasily Polovnyov <vast@whiteants.net>
*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
  -webkit-text-size-adjust: none;
}

.hljs-comment,
.diff .hljs-header,
.hljs-javadoc {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.css .rule .hljs-keyword,
.hljs-winutils,
.nginx .hljs-title,
.hljs-subst,
.hljs-request,
.hljs-status {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-hexcolor,
.ruby .hljs-constant {
  color: #008080;
}

.hljs-string,
.hljs-tag .hljs-value,
.hljs-phpdoc,
.hljs-dartdoc,
.tex .hljs-formula {
  color: #d14;
}

.hljs-title,
.hljs-id,
.scss .hljs-preprocessor {
  color: #900;
  font-weight: bold;
}

.hljs-list .hljs-keyword,
.hljs-subst {
  font-weight: normal;
}

.hljs-class .hljs-title,
.hljs-type,
.vhdl .hljs-literal,
.tex .hljs-command {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-tag .hljs-title,
.hljs-rules .hljs-property,
.django .hljs-tag .hljs-keyword {
  color: #000080;
  font-weight: normal;
}

.hljs-attribute,
.hljs-variable,
.lisp .hljs-body {
  color: #008080;
}

.hljs-regexp {
  color: #009926;
}

.hljs-symbol,
.ruby .hljs-symbol .hljs-string,
.lisp .hljs-keyword,
.clojure .hljs-keyword,
.scheme .hljs-keyword,
.tex .hljs-special,
.hljs-prompt {
  color: #990073;
}

.hljs-built_in {
  color: #0086b3;
}

.hljs-preprocessor,
.hljs-pragma,
.hljs-pi,
.hljs-doctype,
.hljs-shebang,
.hljs-cdata {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.diff .hljs-change {
  background: #0086b3;
}

.hljs-chunk {
  color: #aaa;
}

        </style>
      </head>
      <body>
        <div class="toc">
          <h1 id="table-of-contents">Table of Contents</h1>
<h2 id="0-how-to-use-this-book-1-page-2-">0. How To Use This Book <a href="#page=2">1</a></h2>
<h2 id="1-async-await-the-good-parts-4-page-5-">1. Async/Await: The Good Parts <a href="#page=5">4</a></h2>
<ol>
<li>Return Values <a href="#page=7">6</a></li>
<li>Error Handling <a href="#page=10">9</a></li>
<li>Retrying Failed Requests <a href="#page=13">12</a></li>
<li>Exercise 1: HTTP Request Loops <a href="#page=15">14</a></li>
<li>Exercise 2: Retrying Failed Requests <a href="#page=16">15</a></li>
</ol>
<h2 id="2-promises-from-the-ground-up-16-page-17-">2. Promises From The Ground Up <a href="#page=17">16</a></h2>
<ol>
<li>Promise Chaining <a href="#page=20">19</a></li>
<li><code>catch()</code> and Other Helpers <a href="#page=24">23</a></li>
</ol>
<h2 id="3-async-await-internals">3. Async/Await Internals</h2>
<h2 id="4-async-await-in-the-wild">4. Async/Await in the Wild</h2>

        </div>
        <div class="chapter">
          <h1 id="how-to-use-this-book">How To Use This Book</h1>
<p><a href="http://thecodebarbarian.com/80-20-guide-to-async-await-in-node.js.html">Async/await</a>
is the single most valuable feature to land in the JavaScript language spec in the last 15 years. The event loop and asynchronous programming in general are exceptional for
building GUIs and servers, but callbacks make error handling tedious and code hard to
read. For example, when <a href="https://risingstack.com/">RisingStack</a> asked Node.js developers
what they struggled with in 2017, asynchronous programming topped the list.</p>
<p><img src="https://i.imgur.com/YQ58zIl.png"></p>
<p>Async/await promises to make asynchronous code as clean and easy to
read as synchronous code in most use cases. Tangled promise chains and complex
user-land libraries like
<a href="https://www.npmjs.com/package/async">async</a> can be replaced with <code>for</code> loops,
<code>if</code> statements, and <code>try/catch</code> blocks that even the most junior of engineers can
make sense of.</p>
<p>The following <a href="https://www.hacksparrow.com/node-js-async-programming.html">JavaScript from a 2012 blog post</a> is a typical
example of where code goes wrong with callbacks. This code works,
but it has a lot of error handling boilerplate and deeply nested <code>if</code> statements
that obfuscate the actual logic. Wrapping your mind around it takes a while,
and proper error handling means copy/pasting <code>if (err != null)</code> into every
callback.</p>
<div class="page-break"></div>

<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWikipediaHeaders</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// i. check if headers.txt exists</span>
  fs.stat(<span class="hljs-string">'./headers.txt'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, stats</span>) </span>{
    <span class="hljs-keyword">if</span> (err != <span class="hljs-literal">null</span>) { <span class="hljs-keyword">throw</span> err; }
    <span class="hljs-keyword">if</span> (stats == <span class="hljs-literal">undefined</span>) {
      <span class="hljs-comment">// ii. fetch the HTTP headers</span>
      <span class="hljs-keyword">var</span> options = { <span class="hljs-attr">host</span>: <span class="hljs-string">'www.wikipedia.org'</span>, <span class="hljs-attr">port</span>: <span class="hljs-number">80</span> };
      http.get(options, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, res</span>) </span>{
        <span class="hljs-keyword">if</span> (err != <span class="hljs-literal">null</span>) { <span class="hljs-keyword">throw</span> err; }
        <span class="hljs-keyword">var</span> headers = <span class="hljs-built_in">JSON</span>.stringify(res.headers);
        <span class="hljs-comment">// iii. write the headers to headers.txt</span>
        fs.writeFile(<span class="hljs-string">'./headers.txt'</span>, headers, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
          <span class="hljs-keyword">if</span> (err != <span class="hljs-literal">null</span>) { <span class="hljs-keyword">throw</span> err; }
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Great Success!'</span>);
        });
      });    
    } <span class="hljs-keyword">else</span> { <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'headers already collected'</span>); }
  });
}
</code></pre>
<p>Below is the same code using async/await, assuming that <code>stat()</code>, <code>get()</code>, and
<code>writeFile()</code> are properly promisified.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWikipediaHeaders</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> stat(<span class="hljs-string">'./headers.txt'</span>) != <span class="hljs-literal">null</span>) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'headers already collected'</span>);
  }
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> get({ <span class="hljs-attr">host</span>: <span class="hljs-string">'www.wikipedia.org'</span>, <span class="hljs-attr">port</span>: <span class="hljs-number">80</span> });
  <span class="hljs-keyword">await</span> writeFile(<span class="hljs-string">'./headers.txt'</span>, <span class="hljs-built_in">JSON</span>.stringify(res.headers));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Great success!'</span>);
}
</code></pre>
<p>You might not think async/await is a big deal. You might even think async/await
is a bad idea. I&#39;ve been in your shoes: when I first learned about async/await in
2013, I thought it was unnecessary at best. But when I
started working with generator-based coroutines (the 2015 predecessor to async/await),
I was shocked at how quickly server crashes due to
<code>TypeError: Cannot read property &#39;x&#39; of undefined</code> vanished. By the time async/await
became part of the JavaScript language spec in 2017, async/await was an
indispensable part of my dev practice.</p>
<p>Just because async/await is now officially part of JavaScript doesn&#39;t mean
the world is all sunshine and rainbows. Async/await is a new pattern that
promises to make day-to-day development work easier, but, like any pattern, you
need to understand it or you&#39;ll do more harm than good. If your async/await
code is a patchwork of copy/pasted StackOverflow answers, you&#39;re just trading
callback hell for the newly minted <a href="https://medium.freecodecamp.org/avoiding-the-async-await-hell-c77a0fb71c4c">async/await hell</a>.</p>
<p>The purpose of this book is to take you from someone who is casually acquainted
with promises and async/await to someone who is comfortable building and debugging
a complex app whose core logic is built on async/await. This book is only
50 pages and is meant to be read in about 2 hours total. You may read it all in
one sitting, but you would be better served reading one chapter at a time,
studying the exercises at the end, and getting a good night&#39;s sleep in between
chapters to really internalize the information.</p>
<p>This book is broken up into 4 chapters. Each chapter is 12 pages, including
exercises at the end of each chapter that highlight key lessons from the chapter.
The exercises require more thought than
code and should be easy to answer within a few minutes.</p>
<p>The first 3 chapters are focused on promise and async/await fundamentals, and strive
to avoid frameworks and outside dependencies. In particular, the first 3 chapters&#39;
code samples and exercises are meant to run in Node.js 8.x and the first 3 chapters
will <strong>not</strong> cover transpilers. In the interest of providing realistic examples,
the code samples will use the <code>superagent</code> module for making HTTP requests. The
4th chapter will discuss transpilers and integrating async/await with some common
npm modules.</p>
<p>If you find any issues with the code samples or exercises,
please report them at <a href="https://github.com/vkarpov15/mastering-async-await-issues">github.com/vkarpov15/mastering-async-await-issues</a>.</p>
<p>Are you ready to master async/await? Let&#39;s get started!</p>

        </div>
        <div class="chapter">
          <h1 id="async-await-the-good-parts">Async/Await: The Good Parts</h1>
<p>The <code>async</code> and <code>await</code> keywords are new additions to JavaScript as part of the
2017 edition of the language specification. The <code>async</code> keyword modifies a function,
either a normal <code>function() {}</code> or an arrow function <code>() =&gt; {}</code>, to mark it as an
<em>async function</em>. In an async function, you can use the <code>await</code> keyword to pause
the function&#39;s execution until a promise settles. In the below function, the <code>await</code>
keyword pauses the function&#39;s execution for approximately 1 second.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.1</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// This function will print "Hello, World!" after 1 second.</span>
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(), <span class="hljs-number">1000</span>));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
}

test();
</code></pre>
<p>You can use the <code>await</code> keyword anywhere in the body of an async function. This means
you can use <code>await</code> in <code>if</code> statements, <code>for</code> loops, and <code>try/catch</code> blocks. Below
is another way to pause an async function&#39;s execution for about 1 second.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.2</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Wait for 100ms 10 times. This function also prints after 1 second.</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) {
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(), <span class="hljs-number">100</span>));
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
}

test();
</code></pre>
<p>There is one major restriction for using <code>await</code>: you can only use <code>await</code>
within the body of a function that&#39;s marked <code>async</code>. The following code throws a
<code>SyntaxError</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.3</div></div>

<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(), <span class="hljs-number">1000</span>));
  <span class="hljs-comment">// SyntaxError: Unexpected identifier</span>
  <span class="hljs-keyword">await</span> p;
}

test();
</code></pre>
<p>In particular, you can&#39;t use <code>await</code> in a closure embedded in an async function, unless
the closure is also an async function. The below code also throws a <code>SyntaxError</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.4</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'test'</span>);
  assert.doesNotThrow(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// "SyntaxError: Unexpected identifier" because the above function</span>
    <span class="hljs-comment">// is **not** marked async. "Closure" = function inside a function</span>
    <span class="hljs-keyword">await</span> p;
  });
}
</code></pre>
<p>As long as you don&#39;t create a new function, you can use <code>await</code> underneath any
number of <code>for</code> loops and <code>if</code> statements.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.5</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// Convoluted way to print out "Hello, World!" once per second by</span>
    <span class="hljs-comment">// pausing execution for 200ms 5 times</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) {
      <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(), <span class="hljs-number">200</span>));
      }
    }
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
  }
}
</code></pre>
<div class="page-break"></div>

<h2 id="return-values">Return Values</h2>
<p>You can use <code>async/await</code> for more than just pausing execution. The return
value of <code>await</code> is the value the promise is fulfilled with. This means you can
assign a variable to an asynchronously-computed value in code that looks
synchronous.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.6</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// You can `await` on a non-promise without getting an error.</span>
  <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> <span class="hljs-string">'Hello World!'</span>;
  <span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">// "Hello, World!"</span>

  <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
    <span class="hljs-comment">// This promise resolves to "Hello, World!" after 1s</span>
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-string">'Hello, World!'</span>), <span class="hljs-number">1000</span>);
  });
  res = <span class="hljs-keyword">await</span> promise;
  <span class="hljs-comment">// Prints "Hello, World!". `res` is equal to the value the</span>
  <span class="hljs-comment">// promise resolved to.</span>
  <span class="hljs-built_in">console</span>.log(res);

  <span class="hljs-comment">// Prints "Hello, World!". You can use `await` in function params!</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> promise);
}
</code></pre>
<p>An async function <strong>always</strong> returns a promise. When you <code>return</code> from an async
function, JavaScript resolves the promise to the value you returned. This means
calling async functions from other async functions is very natural. You can
<code>await</code> on the async function call and get the async function&#39;s &quot;return value&quot;.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.7</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeValue</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(), <span class="hljs-number">1000</span>));
  <span class="hljs-comment">// "Hello, World" is the _resolved value_ for this function call</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, World!'</span>;
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Prints "Hello, World!" after 1s. `computeValue` returns a promise!</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> computeValue());
}
</code></pre>
<p>This book will refer to the value you <code>return</code> from an async function as the
<em>resolved value</em>. In <code>computeValue</code> above, &quot;Hello, World!&quot; is the resolved
value, <code>computeValue()</code> still returns a promise. This distinction is subtle
but important: the value you <code>return</code> from an async function body is <strong>not</strong>
the value that an async function call like <code>computeValue()</code> without <code>await</code>
returns.</p>
<p>You can also return a promise from an async function. In that case, the
promise the async function returns will be fulfilled or rejected whenever the
resolved value promise is fulfilled or rejected. Below is another async function that fulfills to &#39;Hello, World!&#39; after 1 second:</p>
<div class="example-header-wrap"><div class="example-header">Example 1.8</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeValue</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// The resolved value is a promise. The promise returned from</span>
  <span class="hljs-comment">// `computeValue()` will be fulfilled with 'Hello, World!'</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-string">'Hello, World!'</span>));
  }, <span class="hljs-number">1000</span>);
}
</code></pre>
<p>If you <code>return</code> a promise from an async function, the resolved value will
still not equal the return value. The below example demonstrates that the
<code>resolvedValue</code> promise that the function body returns is not the same as
the return value from <code>computeValue()</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.9</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> resolvedValue = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Hello, World!'</span>);
<span class="hljs-keyword">const</span> computeValue = <span class="hljs-keyword">async</span> () =&gt; resolvedValue;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// No `await` below, so `returnValue` will be a promise</span>
  <span class="hljs-keyword">const</span> returnValue = computeValue();
  <span class="hljs-comment">// `false`. The return value and resolved value are always different</span>
  <span class="hljs-built_in">console</span>.log(returnValue === resolvedValue);
}
</code></pre>
<p>Async/await beginners often mistakenly think they need to <code>return</code> a promise
from an async function. They likely read that an async function always returns
a promise and think they&#39;re responsible for returning a promise. An async function
always returns a promise, but, like in example 1.9, JavaScript creates the returned promise for you.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.10</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeValue</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Adding `Promise.resolve()` below is unnecessary. It adds</span>
  <span class="hljs-comment">// perf overhead because you're creating an unnecessary promise.</span>
  <span class="hljs-comment">// "Unnecessary code is not as harmless as I used to think. It</span>
  <span class="hljs-comment">// sends the misleading signal that it's necessary." - Paul Graham</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Hello, World!'</span>);
}
</code></pre>
<div class="page-break"></div>

<h2 id="error-handling">Error Handling</h2>
<p>One of the most important properties of async/await is that you can use <code>try/catch</code>
to handle asynchronous errors. Remember that a promise may be either fulfilled
or rejected. When a promise <code>p</code> is fulfilled, JavaScript evaluates <code>await p</code>
to the promise&#39;s value. What about if <code>p</code> is rejected?</p>
<div class="example-header-wrap"><div class="example-header">Example 1.11</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>));
    <span class="hljs-comment">// The below `await` throws</span>
    <span class="hljs-keyword">await</span> p;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.log(err.message); <span class="hljs-comment">// "Oops!"</span>
  }
}
</code></pre>
<p>If <code>p</code> is rejected, <code>await p</code> throws an error that you can catch with a
normal JavaScript <code>try/catch</code>. Note that the <code>await</code> statement is what throws
an error, <strong>not</strong> the promise instantiation.</p>
<p>This <code>try/catch</code> behavior is a powerful tool for consolidating error handling.
The <code>try/catch</code> block above can catch synchronous errors as well as asynchronous
ones. Suppose you have code that throws a <code>TypeError: cannot read property &#39;x&#39; of undefined</code> error:</p>
<div class="example-header-wrap"><div class="example-header">Example 1.12</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> bad = <span class="hljs-literal">undefined</span>;
    bad.x;
    <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>));
    <span class="hljs-keyword">await</span> p;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// "cannot read property 'x' of undefined"</span>
    <span class="hljs-built_in">console</span>.log(err.message);
  }
}
</code></pre>
<p>In callback-based code, you had to watch out for synchronous errors like <code>TypeError</code>
separately from asynchronous errors. This lead to a lot of server crashes and
red text in Chrome consoles, because discipline doesn&#39;t scale.</p>
<p>Consider using a callback-based approach instead of async/await. Suppose you have
a black-box function <code>test()</code> that takes a single parameter, a <code>callback</code>.
If you want to ensure you catch every possible error, you need 2 <code>try/catch</code>
calls: one around <code>test()</code> and one around <code>callback()</code>. You also need to check
whether <code>test()</code> called your callback with an error. In other words, every
single async operation needs 3 distinct error handling patterns!</p>
<div class="example-header-wrap"><div class="example-header">Example 1.13</div></div>

<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testWrapper</span>(<span class="hljs-params">callback</span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// There might be a sync error in `test()`</span>
    test(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
      <span class="hljs-comment">// `test()` might also call the callback with an error</span>
      <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-keyword">return</span> callback(error);
      }
      <span class="hljs-comment">// And you also need to be careful that accessing `res.x` doesn't</span>
      <span class="hljs-comment">// throw **and** calling `callback()` doesn't throw.</span>
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, res.x);
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-keyword">return</span> callback(error);
      }
    });
  }
}
</code></pre>
<p>When there&#39;s this much boilerplate for error handling, even the most rigorous
and disciplined developers end up missing a spot. The result is uncaught errors,
server downtime, and buggy user interfaces. Below is an equivalent example with
async/await. You can handle the 3 distinct error cases from example 1.12 with
a single pattern.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.14</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testWrapper</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// `try/catch` will catch sync errors in `test()`, async promise</span>
    <span class="hljs-comment">// rejections, and errors with accessing `res.x`.</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> test();
    <span class="hljs-keyword">return</span> res.x;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">throw</span> error;
  }
}
</code></pre>
<p>Let&#39;s take a look at how the <code>throw</code> keyword works with async functions now that
you&#39;ve seen how <code>try/catch</code> works. When you <code>throw</code> in an async function,
JavaScript will reject the returned promise.
Remember that the value you <code>return</code> from an async function is called the
resolved value. Similarly, this book will refer to the value you <code>throw</code> in
an async function as the <em>rejected value</em>.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.15</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeValue</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// `err` is the "rejected value"</span>
  <span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>);
  <span class="hljs-keyword">throw</span> err;
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> computeValue();
    <span class="hljs-comment">// Never runs</span>
    <span class="hljs-built_in">console</span>.log(res);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// "Oops!"</span>
  }
}
</code></pre>
<p>Remember that the <code>computeValue()</code> function call itself does <strong>not</strong> throw an
error in the <code>test()</code> function. The <code>await</code> keyword is what throws an error that
you can handle with <code>try/catch</code>. The below code will print &quot;No Error&quot; unless you
uncomment the <code>await</code> block.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.16</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeValue</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>);
};

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> promise = computeValue();
    <span class="hljs-comment">// With the below line commented out, no error will be thrown</span>
    <span class="hljs-comment">// await promise;</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"No Error"</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// Won't run</span>
  }
}
</code></pre>
<div class="page-break"></div>

<p>Just because you can <code>try/catch</code> around a promise doesn&#39;t necessarily mean you
should. Since async functions return promises, you can also use <code>.catch()</code>:</p>
<div class="example-header-wrap"><div class="example-header">Example 1.17</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeValue</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>);
};

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> err = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">await</span> computeValue().catch(<span class="hljs-function"><span class="hljs-params">_err</span> =&gt;</span> { err = _err; });
  <span class="hljs-built_in">console</span>.log(err.message);
}
</code></pre>
<p>Both <code>try/catch</code> and <code>catch()</code> have their place. In particular, <code>catch()</code>
makes it easier to centralize your error handling. A common async/await
novice mistake is putting <code>try/catch</code> at the top of every single function.
If you want a common <code>handleError()</code> function to ensure you&#39;re handing all
errors, you&#39;re better off using <code>catch()</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.18</div></div>

<pre><code class="lang-javascript"><span class="hljs-comment">// If you find yourself doing this, stop!</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">/* Bunch of logic here */</span>
  } <span class="hljs-keyword">catch</span> (err) {
    handleError(err);
  }
}

<span class="hljs-comment">// Do this instead</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">/* Bunch of logic here */</span>
}

fn2().catch(handleError);
</code></pre>
<div class="page-break"></div>

<h2 id="retrying-failed-requests">Retrying Failed Requests</h2>
<p>Let&#39;s tie together loops, return values, and error handling to handle a challenge
that&#39;s painful with callbacks: retrying failed requests. Suppose you had to make
HTTP requests to an unreliable API.</p>
<p>With callbacks or promise chains, retrying failed requests requires recursion,
and recursion is less readable than the synchronous alternative of writing
a <code>for</code> loop. Below is a simplified implementation of a <code>getWithRetry()</code> function
using callbacks and the <a href="https://www.npmjs.com/package/superagent"><code>superagent</code> HTTP client</a>.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.19</div></div>

<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWithRetry</span>(<span class="hljs-params">url, numRetries, callback, retriedCount</span>) </span>{
  retriedCount = retriedCount || <span class="hljs-number">0</span>;
  superagent.get(url).end(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
    <span class="hljs-keyword">if</span> (error) {
      <span class="hljs-keyword">if</span> (retriedCount &gt;= numRetries) { <span class="hljs-keyword">return</span> callback(error); }
      <span class="hljs-keyword">return</span> getWithRetry(url, numRetries, callback, retriedCount + <span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, res.body);
  });
}
</code></pre>
<p>Recursion is subtle and tricky to understand relative to a loop.
Plus, the above code ignores the possibility of sync errors, because the
<code>try/catch</code> spaghetti highlighted in example 1.13 would make this example
unreadable. In short, this pattern is both brittle and cumbersome.</p>
<p>With async/await, you don&#39;t need recursion and you need one <code>try/catch</code> to
handle sync and async errors. The async/await implementation is built on <code>for</code>
loops, <code>try/catch</code>, and other constructs that should be familiar to even the
most junior of engineers.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.20</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWithRetry</span>(<span class="hljs-params">url, numRetries</span>) </span>{
  <span class="hljs-keyword">let</span> lastError = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numRetries; ++i) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// Note that `await superagent.get(url).body` does **not** work</span>
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> superagent.get(url);
      <span class="hljs-comment">// Early return with async functions works as you'd expect</span>
      <span class="hljs-keyword">return</span> res.body;
    } <span class="hljs-keyword">catch</span> (error) {
      lastError = error;
    }
  }
  <span class="hljs-keyword">throw</span> lastError;
}
</code></pre>
<p>More generally, async/await makes executing async operations in series trivial.
For example, let&#39;s say you had to load a list of blog posts from an HTTP API
and then execute a separate HTTP request to load the comments for each blog
post. This example uses the excellent <a href="https://jsonplaceholder.typicode.com/">JSONPlaceholder API</a> that provides good test data.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.21</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> root = <span class="hljs-string">'https://jsonplaceholder.typicode.com'</span>;
  <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> getWithRetry(<span class="hljs-string">`<span class="hljs-subst">${root}</span>/posts`</span>, <span class="hljs-number">3</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> { id } <span class="hljs-keyword">of</span> posts) {
    <span class="hljs-keyword">const</span> comments =
      <span class="hljs-keyword">await</span> getWithRetry(<span class="hljs-string">`<span class="hljs-subst">${root}</span>/comments?postId=<span class="hljs-subst">${id}</span>`</span>, <span class="hljs-number">3</span>);
    <span class="hljs-built_in">console</span>.log(comments);
  }
}
</code></pre>
<p>If this example seems trivial, that&#39;s good, because that&#39;s how programming
should be. The JavaScript community has created an incredible hodge-podge of
tools for executing asynchronous tasks in series, from <a href="https://caolan.github.io/async/docs.html#waterfall"><code>async.waterfall()</code></a> to <a href="https://www.npmjs.com/package/redux-saga">Redux sagas</a> to <a href="https://github.com/domenic/zones">zones</a> to <a href="https://www.npmjs.com/package/co">co</a>. Async/await makes all of these libraries
and more unnecessary. Do you even need <a href="https://www.codementor.io/vkarpov/beginner-s-guide-to-redux-middleware-du107uyud">Redux middleware</a> anymore?</p>
<p>This isn&#39;t the whole story with async/await. This chapter glossed over numerous
important details, including how promises integrate with async/await and
what happens when two asynchronous functions run simultaneously. Chapter 2
will focus on the internals of promises, including the difference between
&quot;resolved&quot; and &quot;fulfilled&quot;, and explain why promises are perfectly suited
for async/await.</p>
<div class="page-break"></div>

<h2 id="exercise-1-http-request-loops">Exercise 1: HTTP Request Loops</h2>
<p>The purpose of this exercise is to get comfortable with using
loops and <code>if</code> statements with async/await. You will need to use
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"><code>fetch()</code> API</a>
to get a list of blog posts on
thecodebarbarian.com, and then
execute a separate <code>fetch()</code> to get the raw markdown <code>content</code>
for each blog post.</p>
<p>Below are the API endpoints. The API endpoints are hosted on
Google Cloud Functions at <code>https://us-central1-mastering-async-await.cloudfunctions.net</code>.</p>
<ul>
<li><code>/posts</code>
gets a list of blog posts. Below is an example post:</li>
</ul>
<pre><code>{ <span class="hljs-string">"src"</span>:<span class="hljs-string">"./lib/posts/20160304_circle_ci.md"</span>,
  <span class="hljs-string">"title"</span>:<span class="hljs-string">"Setting Up Circle CI With Node.js"</span>,
  <span class="hljs-string">"date"</span>:<span class="hljs-string">"2016-03-04T00:00:00.000Z"</span>,
  <span class="hljs-string">"tags"</span>:[<span class="hljs-string">"NodeJS"</span>],
  <span class="hljs-string">"id"</span>:<span class="hljs-number">51</span>}
</code></pre><ul>
<li><code>/post?id=${id}</code>
gets the markdown content of a blog post by its <code>id</code> property.
The above blog post has <code>id</code> = 0, so you can get its content from
this endpoint: <a href="https://us-central1-mastering-async-await.cloudfunctions.net/post?id=0"><code>https://us-central1-mastering-async-await.cloudfunctions.net/post?id=0</code></a>. Try opening this URL in your browser, the output looks
like this:</li>
</ul>
<pre><code>{<span class="hljs-string">"content"</span>:<span class="hljs-string">"*This post was featured as a guest blog post..."</span>}
</code></pre><p>Loop through the blog posts and find the id of the first post
whose <code>content</code> contains the string &quot;async/await hell&quot;.</p>
<p>Below is the starter code. You may copy this code and run it in Node.js using <a href="https://www.npmjs.com/package/node-fetch">the <code>node-fetch</code> npm module</a>, or you may complete this exercise in your browser
on CodePen at <a href="http://bit.ly/async-await-exercise-1"><code>http://bit.ly/async-await-exercise-1</code></a></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> root = <span class="hljs-string">'https://'</span> +
  <span class="hljs-string">'us-central1-mastering-async-await.cloudfunctions.net'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Example of using `fetch()` API</span>
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`<span class="hljs-subst">${root}</span>/posts`</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> res.json());
}

run().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(error.stack));
</code></pre>
<div class="page-break"></div>

<h2 id="exercise-2-retrying-failed-requests">Exercise 2: Retrying Failed Requests</h2>
<p>The purpose of this exercise is to implement a function that retries failed
HTTP requests using async/await and <code>try/catch</code> to handle errors. This example
builds on the correct answer to exercise 1.1, but with the added caveat that
every other <code>fetch()</code> request fails.</p>
<p>For this exercise, you need to implement the <code>getWithRetry()</code> function below.
This function should <code>fetch()</code> the <code>url</code>, and if the request fails this
function should retry the request up to <code>numRetries</code> times. If you see
&quot;Correct answer: 76&quot;, congratulations, you completed this exercise.</p>
<p>Like exercise 1.1, you can complete this exercise locally by copying the
below code and using the <a href="https://www.npmjs.com/package/node-fetch"><code>node-fetch</code> npm module</a>.
You can also complete this exercise in your browser on CodePen at the following
url: <a href="http://bit.ly/async-await-exercise-2">http://bit.ly/async-await-exercise-2</a>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWithRetry</span>(<span class="hljs-params">url, numRetries</span>) </span>{
  <span class="hljs-keyword">return</span> fetch(url).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json());
}

<span class="hljs-comment">// Correct answer for exercise 1.1 below</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> root = <span class="hljs-string">'https://'</span> +
    <span class="hljs-string">'us-central1-mastering-async-await.cloudfunctions.net'</span>;
  <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> getWithRetry(<span class="hljs-string">`<span class="hljs-subst">${root}</span>/posts`</span>, <span class="hljs-number">3</span>);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> post <span class="hljs-keyword">of</span> posts) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Fetch post <span class="hljs-subst">${post.id}</span>`</span>);
    <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> getWithRetry(<span class="hljs-string">`<span class="hljs-subst">${root}</span>/post?id=<span class="hljs-subst">${post.id}</span>`</span>, <span class="hljs-number">3</span>);
    <span class="hljs-keyword">if</span> (content.content.includes(<span class="hljs-string">'async/await hell'</span>)) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Correct answer: <span class="hljs-subst">${post.id}</span>`</span>);
      <span class="hljs-keyword">break</span>;
    }
  }
}

run().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(error.stack));

<span class="hljs-comment">// This makes every 2nd `fetch()` fail</span>
<span class="hljs-keyword">const</span> _fetch = fetch;
<span class="hljs-keyword">let</span> calls = <span class="hljs-number">0</span>;
(<span class="hljs-built_in">window</span> || global).fetch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Hard-coded fetch() error'</span>);
  <span class="hljs-keyword">return</span> (++calls % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) ? <span class="hljs-built_in">Promise</span>.reject(err) : _fetch(url);
}
</code></pre>

        </div>
        <div class="chapter">
          <h1 id="promises-from-the-ground-up">Promises From The Ground Up</h1>
<p>Async/await is built on top of promises. Async functions return promises, and
<code>await</code> only pauses an async function when it operates on a promise.
In order to grok the internals of async/await, you need to understand how
promises work from base principles. JavaScript promises didn&#39;t become what they
are by accident, they were carefully designed to enable paradigms like
async/await.</p>
<p>In the ES6 spec, a <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-executor">promise is a class</a> whose
constructor takes an <code>executor</code> function. Instances of the Promise class have a
<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise.prototype.then"><code>then()</code> function</a>. Promises in the ES6 spec have several other properties, but for now you can
ignore them. Below is a skeleton of a simplified <code>Promise</code> class.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.1</div></div>

<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>{
  <span class="hljs-comment">// `executor` takes 2 parameters, `resolve()` and `reject()`.</span>
  <span class="hljs-comment">// The executor function is responsible for calling `resolve()`</span>
  <span class="hljs-comment">// or `reject()` when the async operation succeeded or failed</span>
  <span class="hljs-keyword">constructor</span>(executor) {}

  <span class="hljs-comment">// `onFulfilled` is called if the promise is fulfilled, and</span>
  <span class="hljs-comment">// `onRejected` if the promise is rejected. For now, you can</span>
  <span class="hljs-comment">// think of 'fulfilled' and 'resolved' as the same thing.</span>
  then(onFulfilled, onRejected) {}
}
</code></pre>
<p>A promise is a state machine with 3 states:</p>
<ul>
<li>pending: the initial state, means that the underlying operation is in progress</li>
<li>fulfilled: the underlying operation succeeded and has an associated value</li>
<li>rejected: the underlying operation failed and has an associated error</li>
</ul>
<p>A promise that is not pending is called <em>settled</em>. In other words, a settled
promise is either fulfilled or rejected. Once a promise is settled,
it <strong>cannot</strong> change state.
For example, the below promise will remain fulfilled despite the <code>reject()</code> call.
Once you&#39;ve called <code>resolve()</code> or <code>reject()</code> once, calling <code>resolve()</code> or <code>reject()</code>
is a no-op. This detail is pivotal for async/await, because how would <code>await</code> work
if a promise changed state from &#39;FULFILLED&#39; to &#39;REJECTED&#39; after an async function was done?</p>
<div class="example-header-wrap"><div class="example-header">Example 2.2</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  resolve(<span class="hljs-string">'foo'</span>);
  <span class="hljs-comment">// The below `reject()` is a no-op. A fulfilled promise stays</span>
  <span class="hljs-comment">// fulfilled with the same value forever.</span>
  reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'bar'</span>));
});
</code></pre>
<p>Below is a diagram showing the promise state machine.</p>
<svg xmlns="http://www.w3.org/2000/svg" width="600" height="390" viewbox="0 0 400 260">
  <line x1="100" y1="150" x2="300" y2="80" style="stroke:#000;stroke-width:5" />
  <line x1="100" y1="150" x2="300" y2="220" style="stroke:#000;stroke-width:5" />

  <line x1="245" y1="100" x2="220" y2="94" style="stroke:#000;stroke-width:5" />
  <line x1="245" y1="100" x2="232" y2="119" style="stroke:#000;stroke-width:5" />

  <line x1="245" y1="200" x2="230" y2="180" style="stroke:#000;stroke-width:5" />
  <line x1="245" y1="200" x2="220" y2="206" style="stroke:#000;stroke-width:5" />

  <!-- Pending -->
  <ellipse rx="75" ry="30" cx="100" cy="150" fill="#000"/>
  <ellipse rx="72" ry="27" cx="100" cy="150" fill="#fff"/>
  <text x="49" y="158" font-family="Roboto" font-size="24">
    PENDING
  </text>

  <!-- Fulfilled -->
  <ellipse rx="75" ry="30" cx="300" cy="80" fill="#000"/>
  <ellipse rx="72" ry="27" cx="300" cy="80" fill="#fff"/>
  <text x="243" y="89" font-family="Roboto" font-size="24">
    FULFILLED
  </text>

  <!-- Rejected -->
  <ellipse rx="75" ry="30" cx="300" cy="220" fill="#000"/>
  <ellipse rx="72" ry="27" cx="300" cy="220" fill="#fff"/>
  <text x="245" y="228" font-family="Roboto" font-size="24">
    REJECTED
  </text>

  <!-- Settled -->
  <line x1="200" y1="250" x2="200" y2="50" style="stroke:#f00;stroke-width:5" />
  <text x="250" y="30" font-family="Roboto" font-size="24" fill="red">
    SETTLED
  </text>
</svg>

<p>With this in mind, below is a first draft of a promise constructor that implements
the state transitions. Note that the property names <code>state</code>, <code>resolve</code>,
<code>reject</code>, and <code>value</code> used below are non-standard. Actual ES6 promises do <strong>not</strong>
expose these properties publicly, so don&#39;t try to use <code>p.value</code> or <code>p.resolve()</code>
with a native JavaScript promise.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.4</div></div>

<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>{
  <span class="hljs-keyword">constructor</span>(executor) {
    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'PENDING'</span>;
    <span class="hljs-keyword">this</span>.chained = []; <span class="hljs-comment">// Not used yet</span>
    <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">undefined</span>;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// Reject if the executor throws a sync error</span>
      executor(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-keyword">this</span>.resolve(v), err =&gt; <span class="hljs-keyword">this</span>.reject(err));
    } <span class="hljs-keyword">catch</span> (err) { <span class="hljs-keyword">this</span>.reject(err); }
  }
  <span class="hljs-comment">// Define `resolve()` and `reject()` to change the promise state</span>
  resolve(value) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state !== <span class="hljs-string">'PENDING'</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'FULFILLED'</span>;
    <span class="hljs-keyword">this</span>.value = value;
  }
  reject(value) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state !== <span class="hljs-string">'PENDING'</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'REJECTED'</span>;
    <span class="hljs-keyword">this</span>.value = value;
  }
}
</code></pre>
<p>The promise constructor manages the promise&#39;s state and calls the executor
function. You also need to implement the <code>then()</code> function that
let clients define handlers that run when a promise is settled. The <code>then()</code>
function takes 2 function parameters, <code>onFulfilled()</code> and <code>onRejected()</code>.
A promise must call the <code>onFulfilled()</code> callback if the promise is fulfilled,
and <code>onRejected()</code> if the promise is rejected.</p>
<p>For now, <code>then()</code> is simple, it push <code>onFulfilled()</code> and
<code>onRejected()</code> onto an array <code>chained</code>. Then, <code>resolve()</code> and <code>reject()</code> will call
them when the promise is fulfilled or rejected. If the promise is already
settled, the <code>then()</code> function will queue up <code>onFulfilled()</code> or <code>onRejected()</code>
to run on the next tick of the event loop using <code>setImmediate()</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.5</div></div>

<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>{
  <span class="hljs-comment">// Constructor is the same as before, omitted for brevity</span>
  then(onFulfilled, onRejected) {
    <span class="hljs-keyword">const</span> { value, state } = <span class="hljs-keyword">this</span>;
    <span class="hljs-comment">// If promise is already settled, enqueue the right handler</span>
    <span class="hljs-keyword">if</span> (state === <span class="hljs-string">'FULFILLED'</span>) <span class="hljs-keyword">return</span> setImmediate(onFulfilled, value);
    <span class="hljs-keyword">if</span> (state === <span class="hljs-string">'REJECTED'</span>) <span class="hljs-keyword">return</span> setImmediate(onRejected, value);
    <span class="hljs-comment">// Otherwise, track `onFulfilled` and `onRejected` for later</span>
    <span class="hljs-keyword">this</span>.chained.push({ onFulfilled, onRejected });
  }
  resolve(value) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state !== <span class="hljs-string">'PENDING'</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'FULFILLED'</span>;
    <span class="hljs-keyword">this</span>.value = value;
    <span class="hljs-comment">// Loop through the `chained` array and find all `onFulfilled()`</span>
    <span class="hljs-comment">// functions. Remember that `.then(null, onRejected)` is valid.</span>
    <span class="hljs-keyword">this</span>.chained.
      filter(<span class="hljs-function">(<span class="hljs-params">{ onFulfilled }</span>) =&gt;</span> <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">'function'</span>).
      <span class="hljs-comment">// The ES6 spec section 25.4 says `onFulfilled` and</span>
      <span class="hljs-comment">// `onRejected` must be called on a separate event loop tick</span>
      forEach(<span class="hljs-function">(<span class="hljs-params">{ onFulfilled }</span>) =&gt;</span> setImmediate(onFulfilled, value));
  }
  reject(value) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state !== <span class="hljs-string">'PENDING'</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'REJECTED'</span>;
    <span class="hljs-keyword">this</span>.value = value;
    <span class="hljs-keyword">this</span>.chained.
      filter(<span class="hljs-function">(<span class="hljs-params">{ onRejected }</span>) =&gt;</span> <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">'function'</span>).
      forEach(<span class="hljs-function">(<span class="hljs-params">{ onFulfilled }</span>) =&gt;</span> setImmediate(onFulfilled, value));
  }
}
</code></pre>
<p>This <code>Promise</code> class, while simple, represents most of the work necessary
to integrate with async/await. The <code>await</code> keyword doesn&#39;t explicitly check
if the value it operates on is <code>instanceof Promise</code>, it only checks for the
presence of a <code>then()</code> function. In general, any object that has a <code>then()</code>
function is called a <em>thenable</em> in JavaScript. Below is an example of using the
custom <code>Promise</code> class with async/await.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.6</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Works, even though this is a custom `Promise` class. All you</span>
  <span class="hljs-comment">// need is a `then()` function to integrate with `await`.</span>
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-string">'Hello'</span>), <span class="hljs-number">50</span>);
  });
  assert.equal(res, <span class="hljs-string">'Hello'</span>);
}
</code></pre>
<h2 id="promise-chaining">Promise Chaining</h2>
<p>One key feature that the promise implementation thus far does not support is
promise chaining. Promise chaining is a common pattern for keeping async code
flat, although it has become far less useful now that generators and async/await
have widespread support. Here&#39;s how the <code>getWikipediaHeaders()</code> function
from the introduction looks with promise chaining:</p>
<div class="example-header-wrap"><div class="example-header">Example 2.7</div></div>

<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWikipediaHeaders</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> stat(<span class="hljs-string">'./headers.txt'</span>).
    then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (res == <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// If you return a promise from `onFulfilled()`, the next</span>
        <span class="hljs-comment">// `then()` call's `onFulfilled()` will get called when</span>
        <span class="hljs-comment">// the returned promise is fulfilled...</span>
        <span class="hljs-keyword">return</span> get({ <span class="hljs-attr">host</span>: <span class="hljs-string">'www.wikipedia.org'</span>, <span class="hljs-attr">port</span>: <span class="hljs-number">80</span> });
      }
      <span class="hljs-keyword">return</span> res;
    }).
    then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
      <span class="hljs-comment">// So whether the above `onFulfilled()` returns a primitive or a</span>
      <span class="hljs-comment">// promise, this `onFulfilled()` gets the headers object</span>
      <span class="hljs-keyword">return</span> writeFile(<span class="hljs-string">'./headers.txt'</span>, <span class="hljs-built_in">JSON</span>.stringify(res.headers));
    }).
    then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Great success!'</span>)).
    catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.err(err.stack));
}
</code></pre>
<p>While async/await is a superior pattern, promise chaining is still useful,
and still necessary to complete a robust promise implementation. In order
to implement promise chaining, you need to make 3 changes to the promise
implementation from example 2.5:</p>
<ol>
<li>The <code>then()</code> function needs to return a promise. The promise returned from <code>then()</code> should be resolved with the value returned from <code>onFulfilled()</code></li>
<li>The <code>resolve()</code> function needs to check if <code>value</code> is a thenable, and, if so, transition to fulfilled or rejected only when <code>value</code> transitions to fulfilled or rejected.</li>
<li>If <code>resolve()</code> is called with a thenable, the promise needs to stay &#39;PENDING&#39;, but future calls to <code>resolve()</code> and <code>reject()</code> must be ignored.</li>
</ol>
<p>The first change, improving the <code>then()</code> function, is shown below. There are
two other changes: <code>onFulfilled()</code> and <code>onRejected()</code> now have default
values, and are wrapped in a try/catch.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.8</div></div>

<pre><code class="lang-javascript">then(_onFulfilled, _onRejected) {
  <span class="hljs-comment">// `onFulfilled` is a no-op by default...</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> _onFulfilled !== <span class="hljs-string">'function'</span>) _onFulfilled = (<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v);
  <span class="hljs-comment">// and `onRejected` just rethrows the error by default</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> _onRejected !== <span class="hljs-string">'function'</span>) {
    _onRejected = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> { <span class="hljs-keyword">throw</span> err; };
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-comment">// Wrap `onFulfilled` and `onRejected` for two reasons:</span>
    <span class="hljs-comment">// consistent async and `try/catch`</span>
    <span class="hljs-keyword">const</span> onFulfilled = <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> setImmediate(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">try</span> {
        resolve(_onFulfilled(res));
      } <span class="hljs-keyword">catch</span> (err) { reject(err); }
    });
    <span class="hljs-keyword">const</span> onRejected = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> setImmediate(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// Note this is `resolve()`, **not** `reject()`. The `then()`</span>
        <span class="hljs-comment">// promise will be fulfilled if `onRejected` doesn't rethrow</span>
        resolve(_onRejected(err));
      } <span class="hljs-keyword">catch</span> (err) { reject(err); }
    });

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === <span class="hljs-string">'FULFILLED'</span>) <span class="hljs-keyword">return</span> onFulfilled(<span class="hljs-keyword">this</span>.value);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === <span class="hljs-string">'REJECTED'</span>) <span class="hljs-keyword">return</span> onRejected(<span class="hljs-keyword">this</span>.value);
    <span class="hljs-keyword">this</span>.chained.push({ onFulfilled, onRejected });
  });
}
</code></pre>
<p>Now <code>then()</code> returns a promise. However, there&#39;s still work to be done: if
<code>onFulfilled()</code> returns a promise, <code>resolve()</code> needs to be able to handle it.
In order to support this, the <code>resolve()</code> function will need to use <code>then()</code>
in a two-step recursive dance. Below is the expanded <code>resolve()</code> function
that shows the 2nd necessary change.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.9</div></div>

<pre><code class="lang-javascript">resolve(value) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state !== <span class="hljs-string">'PENDING'</span>) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">if</span> (value === <span class="hljs-keyword">this</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.reject(<span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`Can't resolve promise with itself`</span>);
  }
  <span class="hljs-comment">// Is `value` a thenable? If so, fulfill/reject this promise when</span>
  <span class="hljs-comment">// `value` fulfills or rejects. The Promises/A+ spec calls this</span>
  <span class="hljs-comment">// process "assimilating" the other promise (resistance is futile).</span>
  <span class="hljs-keyword">const</span> then = <span class="hljs-keyword">this</span>._getThenProperty(value);
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> then.call(value, v =&gt; <span class="hljs-keyword">this</span>.resolve(v),
        err =&gt; <span class="hljs-keyword">this</span>.reject(err));
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">return</span> reject(error);
    }
  }

  <span class="hljs-comment">// If `value` is **not** a thenable, transition to fulfilled</span>
  <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'FULFILLED'</span>;
  <span class="hljs-keyword">this</span>.value = value;
  <span class="hljs-keyword">this</span>.chained.
    forEach(<span class="hljs-function">(<span class="hljs-params">{ onFulfilled }</span>) =&gt;</span> setImmediate(onFulfilled, value));
}
<span class="hljs-comment">// Helper to wrap getting the `then()` property because the Promises/A+</span>
<span class="hljs-comment">// spec has 2 tricky details: you can only access the `then` property</span>
<span class="hljs-comment">// once, and if getting `value.then` throws the promise should reject</span>
_getThenProperty(value) {
  <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">if</span> (![<span class="hljs-string">'object'</span>, <span class="hljs-string">'function'</span>].includes(<span class="hljs-keyword">typeof</span> value)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> value.then;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// Unlikely edge case, Promises/A+ section 2.3.3.2 enforces this</span>
    <span class="hljs-keyword">this</span>.reject(error);
  }
}
</code></pre>
<p>Finally, the third change, ensuring that a promise doesn&#39;t change state
once <code>resolve()</code> is called with a thenable, requires changes to both
<code>resolve()</code> and the promise constructor. The motivation for this change
is to ensure that <code>p2</code> in the below example is fulfilled, <strong>not</strong> rejected.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.10</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="hljs-number">50</span>));
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
  resolve(p1);
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>); <span class="hljs-comment">// Ignored because `resolve()` was called</span>
});
</code></pre>
<p>One way to achieve this is to create a helper function that wraps
<code>this.resolve()</code> and <code>this.reject()</code> that ensures <code>resolve()</code> and <code>reject()</code>
can only be called once.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.11</div></div>

<pre><code class="lang-javascript"><span class="hljs-comment">// After you call `resolve()` with a promise, extra `resolve()` and</span>
<span class="hljs-comment">// `reject()` calls will be ignored despite the 'PENDING' state</span>
_wrapResolveReject() {
  <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;
    called = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.resolve(v);
  };
  <span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;
    called = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.reject(err);
  };
  <span class="hljs-keyword">return</span> { resolve, reject };
}
</code></pre>
<p>Once you have this <code>_wrapResolveReject()</code> helper, you need to use it in
<code>resolve()</code>:</p>
<div class="example-header-wrap"><div class="example-header">Example 2.12</div></div>

<pre><code class="lang-javascript">resolve(value) { <span class="hljs-comment">// Beginning omitted for brevity</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">'function'</span>) {
    <span class="hljs-comment">// If `then()` calls `resolve()` with a 'PENDING' promise and then</span>
    <span class="hljs-comment">// throws, the `then()` promise will be fulfilled like example 2.10</span>
    <span class="hljs-keyword">const</span> { resolve, reject } = <span class="hljs-keyword">this</span>._wrapResolveReject();
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> then.call(value, resolve, reject);
    } <span class="hljs-keyword">catch</span> (error) { <span class="hljs-keyword">return</span> reject(error); }
  }
} <span class="hljs-comment">// End omitted for brevity</span>
</code></pre>
<p>Also, you need to use <code>_wrapResolveReject()</code> in the constructor itself:</p>
<div class="example-header-wrap"><div class="example-header">Example 2.13</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">constructor</span>(executor) { <span class="hljs-comment">// Beginning omitted for brevity</span>
  <span class="hljs-comment">// This makes the promise class handle example 2.10 correctly...</span>
  <span class="hljs-keyword">const</span> { resolve, reject } = <span class="hljs-keyword">this</span>._wrapResolveReject();
  <span class="hljs-keyword">try</span> {
    executor(resolve, reject);
    <span class="hljs-comment">// because if `executor` calls `resolve()` and then throws,</span>
    <span class="hljs-comment">// the below `reject()` is a no-op</span>
  } <span class="hljs-keyword">catch</span> (err) { reject(err); }
}
</code></pre>
<p>With all these changes, the complete promise implementation, which you can
find at <a href="http://bit.ly/simple-promise">bit.ly/simple-promise</a>, now passes
all 872 test cases in the <a href="https://promisesaplus.com/">Promises/A+ spec</a>.
The Promises/A+ spec is <a href="https://promisesaplus.com/implementations#the-ecmascript-specification">a subset of the ES6 promise spec</a> that focuses on <code>then()</code> and the promise constructor.</p>
<h2 id="-catch-and-other-helpers"><code>catch()</code> and Other Helpers</h2>
<p>The ES6 promise spec is a superset of the Promises/A+ spec that adds several
convenient helper methods on top of the <code>then()</code> function. The most commonly
used helper is the <code>catch()</code> function. Like the synchronous <code>catch</code> keyword, the
<code>catch()</code> function typically appears at the end of a promise chain to handle
any errors that occurred.</p>
<p>The <code>catch()</code> function may sound complex, but it is just a thin layer of syntactic
sugar on top of <code>then()</code>. The <code>catch()</code> is so sticky because
the name <code>catch()</code> is a powerful metaphor for explaining what this helper is used for.
Below is the full implementation of <code>catch()</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.14</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">catch</span>(onRejected) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, onRejected);
}
</code></pre>
<p>Why does this work? Recall from example 2.8 that <code>then()</code> has a default <code>onRejected()</code>
argument that rethrows the error. So when a promise is rejected, subsequent <code>then()</code>
calls that only specify an <code>onFulfilled()</code> handler are skipped.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.15</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> originalError = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>);
<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> reject(originalError)).
  then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'This will not print'</span>)).
  then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Nor will this'</span>)).
  <span class="hljs-comment">// The `onFulfilled()` handlers above get skipped. Each of the</span>
  <span class="hljs-comment">// `then()` promises above reject with the original error</span>
  <span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> assert.ok(err === originalError));
</code></pre>
<p>There are several other helpers in the ES6 promise spec. The <code>Promise.resolve()</code>
and <code>Promise.reject()</code> helpers are both commonly used for testing and examples,
as well as to convert a thenable into a fully fledged promise.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.16</div></div>

<pre><code class="lang-javascript"><span class="hljs-comment">// Yes, this is actually a thenable. When it comes to promises, the</span>
<span class="hljs-comment">// letter of the law overrules the spirit of the law.</span>
<span class="hljs-keyword">const</span> thenable = { <span class="hljs-attr">then</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>); } };
<span class="hljs-comment">// But `thenable` doesn't have `catch()`, so use `Promise.resolve()`</span>
<span class="hljs-comment">// to convert it to a promise and use `catch()`</span>
<span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve(thenable).
  catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err.message)); <span class="hljs-comment">// Prints "Oops!"</span>
</code></pre>
<p>Below is the implementation of <code>resolve()</code> and <code>reject()</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.17</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">static</span> resolve(v) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(v));
}
<span class="hljs-keyword">static</span> reject(err) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(err));
}
</code></pre>
<p>The <code>Promise.all()</code> function is another important helper, because it lets you execute multiple promises in
parallel and <code>await</code> on the result. <code>Promise.all()</code> is the preferred mechanism
for executing async functions in parallel. To execute async functions in series,
you would use a <code>for</code> loop and <code>await</code> on each function call.</p>
<p>The below code will run two instances of
the <code>run()</code> function in parallel, and pause execution until they&#39;re both done.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.18</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="hljs-number">50</span>));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'run(): running'</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="hljs-number">50</span>));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'run(): done'</span>);
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Start running'</span>);
<span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([run(), run()]);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Done'</span>);
<span class="hljs-comment">// Start running</span>
<span class="hljs-comment">// run(): running</span>
<span class="hljs-comment">// run(): running</span>
<span class="hljs-comment">// run(): done</span>
<span class="hljs-comment">// run(): done</span>
<span class="hljs-comment">// Done</span>
</code></pre>
<p><code>Promise.all()</code> is just a convenient wrapper around calling <code>then()</code> on an array
of promises and waiting for the result. Below is a simplified implementation of
<code>Promise.all()</code>:</p>
<div class="example-header-wrap"><div class="example-header">Example 2.19</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">static</span> all(arr) {
  <span class="hljs-keyword">let</span> remaining = arr.length;
  <span class="hljs-keyword">if</span> (remaining === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve([]);
  <span class="hljs-comment">// `result` stores the value that each promise is fulfilled with</span>
  <span class="hljs-keyword">let</span> result = [];
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-comment">// Loop through every promise in the array and call `then()`. If</span>
    <span class="hljs-comment">// the promise fulfills, store the fulfilled value in `result`.</span>
    <span class="hljs-comment">// If any promise rejects, the `all()` promise rejects immediately.</span>
    arr.forEach(<span class="hljs-function">(<span class="hljs-params">p, i</span>) =&gt;</span> p.then(
      <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
        result[i] = res;
        --remaining || resolve(result);
      },
      err =&gt; reject(err)));
  });
}
</code></pre>
<p>There is one more helper function defined in the ES6 spec, <code>Promise.race()</code>,
that will be an exercise. Other than <code>race()</code> and some minor details like
support for subclassing, the promise implementation in this chapter is
compliant with the ES6 spec. In the next chapter, you&#39;ll use your
understanding of promises to monkey-patch async/await and figure out what&#39;s
happening under the hood.</p>
<p>The key takeaways from this journey
of building a promise library from scratch are:</p>
<ul>
<li>A promise can be in one of 3 states: pending, fulfilled, or rejected. It can also be locked in to match the state of another promise if you call <code>resolve(promise)</code>.</li>
<li>Once a promise is settled, it stays settled with the same value forever</li>
<li>The <code>then()</code> function and the promise constructor are the basis for all other promise functions. The <code>catch()</code>, <code>all()</code>, <code>resolve()</code>, and <code>reject()</code> helpers are all syntactic sugar on top of <code>then()</code> and the constructor.</li>
</ul>
<p>But before you start tinkering with the internals of async/await, here&#39;s 3 exercises
to expand your understanding of promises.</p>

        </div>
      </body>
    </html>
  